/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Element\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.Element),\n/* harmony export */   \"Generator\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.Generator),\n/* harmony export */   \"Component\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.Component),\n/* harmony export */   \"Group\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.Group),\n/* harmony export */   \"Router\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.Router),\n/* harmony export */   \"State\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.State),\n/* harmony export */   \"root\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.root)\n/* harmony export */ });\n/* harmony import */ var _lib_nova__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/nova */ \"./lib/nova.js\");\n\n\n\n\n//# sourceURL=webpack://nova/./index.js?");

/***/ }),

/***/ "./lib/Component.js":
/*!**************************!*\
  !*** ./lib/Component.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Component {\n  #arrayOfElements;\n  #parent\n  #stateUpdaterArray\n\n  constructor(arrayOfElements) {\n    this.#arrayOfElements = arrayOfElements;\n    this.#parent;\n    this.#stateUpdaterArray = [];\n  }\n\n  get elements() {\n    return this.#arrayOfElements;\n  }\n\n  setProps(propsObject) {\n    for (const key in propsObject) {\n      const toFind = `{{${key}}}`;\n      this.#arrayOfElements.forEach(elem => {\n        for (const prop in elem.node) {\n          if (elem.node[prop] === toFind) {\n            elem.node[prop] = propsObject[key];\n          }\n        }\n      })\n    }\n  }\n\n  setState(state) {\n    const statesValues = state.getState();\n    for (const key in statesValues) {\n      const toFind = `{{${key}}}`;\n      this.#arrayOfElements.forEach(elem => {\n        for (const prop in elem.node) {\n          if (elem.node[prop] === toFind) {\n            const updateState = () => {\n              elem.node[prop] = state.getState()[key];\n            }\n            updateState();\n            this.#stateUpdaterArray.push(updateState);\n          }\n        }\n      })\n    }\n  }\n\n  updateState() {\n    this.#stateUpdaterArray.forEach(func => {\n      func();\n    })\n  }\n\n  retrieve(input) {\n    let retrievedElements = [];\n    if(input[0] === '#') {\n      retrievedElements = this.#arrayOfElements\n        .find(element => element.node.id === input.replace('#', ''));\n    } else if (input[0] === '.') {\n      this.#arrayOfElements.forEach(element => {\n        if (element.node.className === input.replace('.', '')) {\n          retrievedElements.push(element);\n        }\n      })\n    } else {\n      this.#arrayOfElements.forEach(element => {\n        if (element.type === input) {\n          retrievedElements.push(element);\n        }\n      })\n    }\n\n    return retrievedElements;\n  }\n\n  changeParent(newParent) {\n    this.#parent = newParent\n    this.#arrayOfElements[0].changeParent(newParent.node);\n  }\n\n  sortInDom(prop = 'id', order = 'ascending') {\n    // Sorts wrappers in groups based on \n    // f.e ID in the DOM elems and just use insertbefores to \n    // change only those that needs to change.\n    // You can also add so it regexes away for example \"task1\" so it just looks for the numbers. \n    /**\n     * Algoritmen:\n     * Nested Loop with one element, \n     * insertBefore on the first element that has the same or higher value than element\n     * \n     */\n  }\n\n  render() {\n    if(this.#parent)\n      this.#parent.addNode();\n    \n    this.#arrayOfElements.forEach(element => {\n      if (element.removed)\n        element.addNode();\n    })\n  }\n\n  unrender() {\n    this.#arrayOfElements.forEach(element => {\n      if (!element.removed)\n        element.removeNode();\n    })\n  }\n\n  deleteByIndex(index) {\n    const targetElement = this.#arrayOfElements[index]\n    if (!targetElement.removed)\n      targetElement.removeNode();\n    this.#arrayOfElements.splice(index, 1);\n  }\n\n  deleteById(id) {\n    const index = this.#arrayOfElements.findIndex(elem => elem.id === id);\n    const targetElement = this.#arrayOfElements[index];\n    if (!targetElement.removed) \n      targetElement.removeNode();\n    this.#arrayOfElements.splice(index, 1);\n\n    console.log(this.#arrayOfElements);\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);\n\n\n//# sourceURL=webpack://nova/./lib/Component.js?");

/***/ }),

/***/ "./lib/Element.js":
/*!************************!*\
  !*** ./lib/Element.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _nova__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nova */ \"./lib/nova.js\");\n\n\n/**\n * @name Element\n * @class\n * @param {string} type\n * An htmlTag, for example 'div' or 'button'. \n * @param {Element|node} parent\n * The parent in the DOM you want the element to belong to.\n * @param {object} elementObject\n * An object containing the javascript props like: { innerText: 'helo' }\n * @param {boolean} init \n * A boolean to indicate if you want to render the element now (default: false). \n * @desc\n * The fundamental building block in Nova is the Element, which most other things in the library are built upon. \n * The element is just a shell of the normal javascript node but adds extra functionality \n * and shorter syntax to access and manipulate a node.\n * @example\n * import { Element, root } from 'nova';\n * const h1 = new Element('h1', root, { innerText: 'Hello World' }, true);\n * @returns void\n */\nclass Element {\n  #type;\n  #parent;\n  #node;\n  #elementObject;\n  #removed;\n  #init;\n\n  constructor(type, parent, elementObject, init) {\n    this.#type = type;\n    this.#parent = parent.node ? parent.node : parent;\n    this.#node = null;\n    this.#elementObject = elementObject;\n    this.#removed = true;\n    this.#init = init\n    this.#createNode();\n    this.#checkInit();\n  }\n  \n  /**\n   * @desc\n   * Return the node of the element\n   * @example\n   * const h1 = new Element('h1', root, { innerText: 'Hello World' }, true);\n   * console.log(h1.node) //returns node\n   * @return {node}\n   *  \n   */\n  get node() {\n    return this.#node;\n  }\n\n   /**\n   * @desc\n   * Return the type of the element\n   * @example\n   * const h1 = new Element('h1', root, { innerText: 'Hello World' }, true);\n   * console.log(h1.type) //returns 'h1'\n   * @return {type}\n   *  \n   */\n  get type() {\n    return this.#type;\n  }\n\n   /**\n   * @desc\n   * Return the parent of the element\n   * @example\n   * const h1 = new Element('h1', root, { innerText: 'Hello World' }, true);\n   * console.log(h1.parent) //returns node of root\n   * @return {parent}\n   */\n  get parent() {\n    return this.#parent;\n  }\n\n   /**\n   * @desc\n   * Return the value of the element\n   * @example\n   * const input = new Element('input', root, { type: 'text', value: 'some text' }, true);\n   * console.log(h1.value) //returns 'some text'\n   * @return {value}\n   */\n  get value() {\n    return this.#node.value;\n  }\n\n   /**\n   * @desc\n   * Return the id of the element\n   * @example\n   * const h1 = new Element('h1', root, { id: 'title', innerText: 'Welcome!' }, true);\n   * console.log(h1.id) //returns 'title'\n   * @return {id}\n   */\n  get id() {\n    return this.#node.id;\n  }\n\n  /**\n   * @desc\n   * Return the text of the element\n   * @example\n   * const h1 = new Element('h1', root, { id: 'title', innerText: 'Welcome!' }, true);\n   * console.log(h1.text) //returns 'Welcome!'\n   * @return {text}\n   */\n  get text() {\n    return this.#node.textContent;\n  }\n\n  /**\n   * @desc\n   * Return the innerHTML of the element\n   * @example\n   * const h1 = new Element('h1', root, { id: 'title', innerText: 'Welcome!' }, true);\n   * console.log(h1.html) //returns '<h1 id=\"title\">Welcome!</h1>'\n   * @return {html}\n   */\n  get html() {\n    return this.#node.innerHTML;\n  }\n\n   /**\n   * @desc\n   * Return the siblings of the element\n   * @example\n   * const h1 = new Element('h1', root, { id: 'title', innerText: 'Welcome,' }, true);\n   * const h2 = new Element('h2', root, { id: 'subtitle', innerText: 'To an awesome page!' }, true);\n   * console.log(h1.siblings) //returns a nodeArray of h1 and h2.\n   * @return {nodeArray}\n   */\n  get siblings() {\n    return this.parent.children;\n  }\n\n  get children() {\n    return this.node.children;\n  }\n\n  get removed() {\n    return this.#removed;\n  }\n\n  #checkInit() {\n    if (this.#init) {\n      this.addNode();\n    } \n  }\n\n  #validateProps(elementObject) {\n    const options = this.#generateOptions();\n    for (const prop in elementObject) {\n      if (!options.includes(prop)) {\n        throw new Error(`Supplied property in updateNode call doesn't exist on type ${this.#type}`);\n      }\n    }\n  }\n\n  #createNode() {\n    const newNode = document.createElement(this.#type);\n    this.#node = newNode;\n    this.#validateProps(this.#elementObject);\n    for (const prop in this.#elementObject) {\n      this.#node[prop] = this.#elementObject[prop];\n    }    \n  }\n\n  #generateOptions() {\n    const optionsArray = [];\n    for (const opt in this.#node) {\n      optionsArray.push(opt);\n    }\n\n    return optionsArray;\n  }\n\n  /**\n   * @desc\n   * Dynamically updates the element by passing an object containing the props you want to update\n   * @param {object} elementObject\n   * An object containing the javascript props like: { innerText: 'helo' }\n   * @example\n   * const h1 = new Element('h1', root, { id: 'welcome', innerText: 'Hello World!' }, true);\n   * h1.updateNode({ id: 'goodbye', innerText: 'Goodbye World...' })\n   * @return {void}\n   */\n  updateNode(elementObject) {\n    this.#validateProps(elementObject);\n\n    this.#elementObject = { ...this.#elementObject, ...elementObject }\n    for (const prop in this.#elementObject) {\n      if (this.#node[prop] !== this.#elementObject[prop])\n        this.#node[prop] = this.#elementObject[prop];\n    }\n  }\n\n   /**\n   * @desc\n   * Toggles node on and off\n   * @example\n   * const h1 = new Element('h1', root, { id: 'welcome', innerText: 'Hello World!' }, true); //On with true\n   * h1.toggleNode() //Off\n   * h1.toggleNode() //On\n   * @return {void}\n   */\n  toggleNode() {\n    if (this.#removed === true) {\n      this.addNode();\n    } else {\n      this.removeNode();\n    }\n  } \n\n  /**\n   * @desc\n   * Appends node to parent, throws error if is already appended. \n   * @example\n   * const h1 = new Element('h1', root, { id: 'welcome', innerText: 'Hello World!' }); //Off\n   * h1.addNode() //On\n   * @return {void}\n   */\n  addNode() {\n    if (this.#removed === false) {\n      throw new Error('Adding a node previously not removed is not possible, try \"copyNode()\" instead.');\n    }\n\n    this.parent.appendChild(this.node);\n    this.#removed = false;\n  }\n  \n   /**\n   * @desc\n   * Removes node from parent. \n   * @example\n   * const h1 = new Element('h1', root, { id: 'welcome', innerText: 'Hello World!'}, true); //On\n   * h1.removeNode() //Off\n   * @return {void}\n   */\n  removeNode() {\n    this.parent.removeChild(this.node);\n    this.#removed = true;\n  }\n\n  /**\n   * @desc\n   * Appends node to new parent. \n   * @param {Element|node} newParentNode\n   * @example\n   * const div = new Element('div', root, { className: 'container' }, true);\n   * const h1 = new Element('h1', root, { id: 'welcome', innerText: 'Hello World!'}, true); //Appends to root\n   * h1.changeParent(div); //Now h1 is appended to div instead.\n   * @return {void}\n   */\n  changeParent(newParentNode) {\n    if (newParentNode.node) {\n      newParentNode = newParentNode.node\n    }\n\n    if (this.#parent !== newParentNode) {\n      this.#parent = newParentNode;\n      this.#parent.appendChild(this.node);\n    }\n  }\n\n  /**\n   * @desc\n   * Calls addEventListener on node. \n   * @param {event} event //f.e 'click'\n   * Any javascript supported event. \n   * @param {function} callback\n   * Callback function to be invoked when event happens. \n   * @example\n   * Check https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n   * @return {void}\n   */\n  addEventListener(event, callback) {\n    this.node.addEventListener(event, callback); \n  }\n\n  /**\n   * @desc\n   * Dynamically adds css styles to Element.\n   * @param {string} property \n   * A string containing what you want to change, for example 'color'\n   * @param {string} css \n   * The css value to use, for example 'red'\n   * @return {void}\n   */\n  addStyle(property, css) {\n    this.#node.style[property] = css;\n  }\n\n  /**\n   * @desc\n   * Creates a component putting the element inside\n   */\n  createComponent() {\n    return new _nova__WEBPACK_IMPORTED_MODULE_0__.Component([this])\n  }\n\n  /**\n   * @desc\n   * Moves node one step up the tree, changing place with it's previous sibling. \n   * @return {void}\n   */\n  beforeSibling() {\n    let childrenList = this.node.parentNode.children;\n    let indexPositionOfTarget = null;\n    for (let i = 0; i < childrenList.length; i++) {\n      if (childrenList[i] === this.node) {\n          indexPositionOfTarget = i;\n          break;\n      }\n    }\n\n    if (indexPositionOfTarget !== 0) {\n      const current = childrenList[indexPositionOfTarget];\n      const prev = childrenList[indexPositionOfTarget - 1]\n      this.#parent.insertBefore(current, prev)\n    } \n\n  }\n\n   /**\n   * @desc\n   * Moves node one step down the tree, changing place with it's next sibling. \n   * @return {void}\n   */\n  afterSibling() {\n    let childrenList = this.node.parentNode.children;\n    let indexPositionOfTarget = null;\n    for (let i = 0; i < childrenList.length; i++) {\n      if (childrenList[i] === this.node) {\n          indexPositionOfTarget = i;\n          break;\n      }\n    }\n\n    if (indexPositionOfTarget < childrenList.length - 1) {\n      const current = childrenList[indexPositionOfTarget];\n      const next = childrenList[indexPositionOfTarget + 1]\n      this.#parent.insertBefore(next, current)\n    } \n  }\n\n  /**\n   * @desc\n   * Appends node after a reference sibling\n   * @param {Element} reference \n   * @returns {void}\n   */\n  after(reference) {\n    const ref = reference.node.nextSibling;\n    if (ref)\n      this.parent.insertBefore(this.node, ref);\n    else \n      this.parent.appendChild(this.node);\n  }\n\n  /**\n   * @desc\n   * Appends node before a reference sibling\n   * @param {Element} reference \n   * @returns {void}\n   */\n  before(reference) {\n    if (reference)\n      this.parent.insertBefore(this.node, reference.node);\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Element);\n\n\n//# sourceURL=webpack://nova/./lib/Element.js?");

/***/ }),

/***/ "./lib/Generator.js":
/*!**************************!*\
  !*** ./lib/Generator.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _nova__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nova */ \"./lib/nova.js\");\n\n\n/**\n * @name Generator\n * @class\n * @desc\n * The generator is a powerful way to generate HTML without writing actual HTML!\n * It's meant to be very straightforward and to give your SPA a nice structure. No more angle brackets!\n * @example\n * import { Generator } from 'nova';\n * const generator = new Generator();\n * const header = generator.createTree(`\n *   header className: 'header'\n *     h1 className: 'header__title' innerText: 'Hello World!'\n *     h2 className: 'header__subtitle' innerText: 'This is my site.'\n * end`)\n * \n * header.render();\n */\nclass Generator {\n  constructor() {\n    this.tokens = [];\n    this.treeObjectArray = [];\n    this.indentationRule = 2\n    this.endToken = 'end'\n    this.rules = {\n      typeExpected: true,\n      valueExpected: false,\n      checkNextTypeIsValue: false\n    }\n  }\n\n  get elements() {\n    return this.elementsArray;\n  }\n\n  get tags() {\n    return [\"a\",\"abbr\",\"acronym\",\"address\",\"applet\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"basefont\",\"bb\",\"bdo\",\"big\",\"blockquote\",\"body\",\"br /\",\"button\",\"canvas\",\"caption\",\"center\",\"cite\",\"code\",\"col\",\"colgroup\",\"command\",\"datagrid\",\"datalist\",\"dd\",\"del\",\"details\",\"dfn\",\"dialog\",\"dir\",\"div\",\"dl\",\"dt\",\"em\",\"embed\",\"eventsource\",\"fieldset\",\"figcaption\",\"figure\",\"font\",\"footer\",\"form\",\"frame\",\"frameset\",\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\"head\",\"header\",\"hgroup\",\"hr /\",\"html\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"isindex\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"map\",\"mark\",\"menu\",\"meta\",\"meter\",\"nav\",\"noframes\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"pre\",\"progress\",\"q\",\"rp\",\"rt\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"small\",\"source\",\"span\",\"strike\",\"strong\",\"style\",\"sub\",\"sup\",\"table\",\"tbody\",\"td\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"tt\",\"u\",\"ul\",\"var\",\"video\",\"wbr\"]\n  }\n  \n  _generateElementsFromTree() {\n    const root = document.getElementById('root');\n    const elementsArray = [];\n    let priorityArray = [];\n    let lowestIndentation = 0;\n    let previousPriority = null;\n    \n    this.treeObjectArray.forEach((object, index) => {\n      if (index === 0) \n        lowestIndentation = object.priority\n      else\n        if (object.priority < lowestIndentation)\n          lowestIndentation = object.priority;\n    })\n\n    let iterations = 0;\n    this.treeObjectArray.forEach((object) => {\n      let element;\n      if (object.priority === lowestIndentation) {\n        element = new _nova__WEBPACK_IMPORTED_MODULE_0__.Element(object.tag, root, object.propertyObject);\n        priorityArray = priorityArray.filter(elem => elem.priority <= object.priority - 2);\n      } else if (object.priority === (previousPriority + 2)) {\n        const parentObject = priorityArray.find(elem => elem.priority === object.priority - 2);\n        element = new _nova__WEBPACK_IMPORTED_MODULE_0__.Element(object.tag, parentObject.element, object.propertyObject);\n      } else if (object.priority <= (previousPriority - 2)) {\n        //Filter out everything that isn't grandparent\n        priorityArray = priorityArray.filter(elem => elem.priority <= object.priority - 2);\n        let parentObject = priorityArray.find(elem => elem.priority === object.priority - 2);\n        element = new _nova__WEBPACK_IMPORTED_MODULE_0__.Element(object.tag, parentObject.element, object.propertyObject);\n      } else if (object.priority === previousPriority) {\n        /* Removing previous priority so it doesn't interfere with paternity*/\n        priorityArray.splice(iterations - 1, 1);\n        iterations--;\n        const parentObject = priorityArray.find(elem => elem.priority === object.priority - 2);\n        element = new _nova__WEBPACK_IMPORTED_MODULE_0__.Element(object.tag, parentObject.element, object.propertyObject);\n      }\n\n      iterations++;\n      elementsArray.push(element);\n      priorityArray.push({ element, priority: object.priority });\n      previousPriority = object.priority;\n    })\n    \n    this.elementsArray = elementsArray;\n  }\n\n  _createTreeObjectFromTokens() {\n    this.tokens.forEach((line, index) => {\n      const indentation = line[0].indentation;\n      const treeObject = {};\n      const propertyObject = {};\n      let tokenValue = false;\n      for (let tokenIndex = 0; tokenIndex < line.length; tokenIndex++) {\n        if (line[tokenIndex].type === 'token_tag') {\n          treeObject.tag = line[tokenIndex].token;\n          treeObject.priority = indentation;\n          continue;\n        } \n\n        if (line[tokenIndex].type === 'token_property') {\n          propertyObject[line[tokenIndex].token] = line[tokenIndex + 1].token;\n          tokenIndex++;\n        }\n      }\n\n      treeObject.propertyObject = propertyObject;\n      this.treeObjectArray.push(treeObject);\n\n    })\n  }\n\n  _checkGrammar(currentToken, lineNumber, currentLineTokens) {\n    /** Grammars\n     * token_tag ex. div section form button\n     * token_property\n     * token_value \n     */\n    const tags = this.tags;\n    let returnType = '';\n\n    if (this.rules.typeExpected) {\n      if (tags.includes(currentToken)) {\n        returnType = 'token_tag';\n      } else if (currentToken === this.endToken) {\n        return 0;\n      } else {\n        console.table(currentToken);\n        throw new Error(`Invalid type, check if applied HTML tag on line ${lineNumber + 1} is valid. To see available tags, console.log(generator.tags)`)\n      }\n    }\n\n    if (this.rules.valueExpected) {\n      const lineType = currentLineTokens[0].token;\n        const testNode = document.createElement(lineType)\n        for (const elem in testNode) {\n          if (elem == currentToken)\n            returnType = 'token_property'\n        }\n\n        if (returnType !== 'token_property')\n          throw new Error(`Invalid property value ${currentToken} for ${lineType}`)\n        return 'token_property';\n    }\n\n    if (this.rules.checkNextTypeIsValue) {\n      if (currentToken[0] === '\\'' && currentToken[currentToken.length - 1] === '\\'') {\n        currentToken = currentToken.replace(/'/g, '');\n        returnType = 'token_value';\n      }\n    }\n\n    return returnType;\n  }\n\n  _generateTokens(inputArr) {\n    const arrayOfLines = inputArr.filter(elem => elem.length !== 0);\n    arrayOfLines.forEach((line, lineNumber) => {\n      const currentLineTokens = [];\n      this.rules.typeExpected = true;\n      let indentation = 0;\n      for (let i = 0; line[i] == ' '; i++) {\n        indentation++;\n      } \n\n      //Rule: Value Expected -- If ':' is found, next grammarcheck type needs to be 'value' else throw error\n      let currentToken = '';\n      let lastChar = ''\n      for (let lineIndex = indentation; lineIndex <= line.length; lineIndex++) {\n        if ((line[lineIndex] !== ' ' && lineIndex !== line.length) && line[lineIndex]) {\n          if (this.rules.valueExpected && line[lineIndex] !== '\\'') \n            throw new Error('Missing \\' after :');         \n\n          if (line[lineIndex] === ':') {\n            this.rules.valueExpected = true;\n            continue;\n          }\n\n          currentToken += line[lineIndex];\n          lastChar = line[lineIndex];\n        } else if (this.rules.checkNextTypeIsValue && lastChar !== '\\'') {\n          currentToken += line[lineIndex];\n          lastChar = line[lineIndex];\n        } else {\n          //Validate token\n          const type = this._checkGrammar(currentToken, lineNumber, currentLineTokens)\n\n          if (this.rules.typeExpected && type !== 'token_tag' && currentToken !== this.endToken) \n            throw new Error(\"type expected as first token! ex. div\");\n          this.rules.typeExpected = false;\n\n          if (this.rules.checkNextTypeIsValue && type !== 'token_value') \n            throw new Error(\"'value' expected after after token_property\")\n          this.rules.checkNextTypeIsValue = false;\n\n          if (this.rules.valueExpected) {\n            this.rules.checkNextTypeIsValue = true;\n            this.rules.valueExpected = false;\n          }\n\n          if (type === 'token_value') \n            currentToken = currentToken.replace(/'/g, '');\n          currentLineTokens.push({ token: currentToken, type });\n          currentToken = '';\n        }\n      }\n\n      currentLineTokens.unshift({ indentation })\n      this.tokens.push(currentLineTokens);\n    })\n  }\n\n  /**\n   * 'createTree' is the method you can use to generate HTML stored in a Component as Elements. \n   * The string has to be in a certain format where indentations are very important.\n   * Indentations are what dictates if an element is a parent/child. Always use even indentations, 2 spaces per child. \n   * The structure is always the same: `[indentation][htmlTag][property]: '[value]'` \n   * like: \n   * @example\n   * `  h1 innerText: 'helo'`\n   * Valid properties are for specific a htmlTag. For example, you can use 'type' on 'input' but not on 'h1'\n   * @example\n   * ` form\n   *     input type: 'text'\n   * end`\n   * \n   * Indentation dictates children/parent\n   * @example\n   * `\n   *   div className: 'grandparent'\n   *     main className: 'parent'\n   *       p className: 'child' innerText: 'I am a child of main'    \n   * end`  \n   * \n   * Always end the string on a new line with the word 'end'\n   *  \n   * Full example\n   * @example\n   * import { Generator } from 'nova';\n   * const generator = new Generator();\n   * const header = generator.createTree(`\n   *   header className: 'header'\n   *     h1 className: 'header__title' innerText: 'Hello World!'\n   *     h2 className: 'header__subtitle' innerText: 'This is my site.'\n   *   nav id: 'menu'\n   *     ul className: 'menu__items'\n   *       li innerText: 'First item'\n   *       li innerText: 'Second item'\n   *   end`)\n   * @param {string} input \n   * @returns {Component}\n   */\n  createTree(input, indentationRule = 2) {\n    this.indentationRule = indentationRule;\n    const splitByNewLines = input.split('\\n');\n    this._generateTokens(splitByNewLines);\n    this._createTreeObjectFromTokens();\n    this._generateElementsFromTree();\n    this.elementsArray.pop();\n    const elementsArray = [...this.elementsArray]\n    this._defaultGenerator()\n    return new _nova__WEBPACK_IMPORTED_MODULE_0__.Component(elementsArray)\n  } \n\n  _defaultGenerator() {\n    this.tokens = [];\n    this.treeObjectArray = [];\n    this.indentationRule = 2\n    this.endToken = 'end'\n    this.rules = {\n      typeExpected: true,\n      valueExpected: false,\n      checkNextTypeIsValue: false\n    }\n    this.elementsArray = [];\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Generator);\n\n//# sourceURL=webpack://nova/./lib/Generator.js?");

/***/ }),

/***/ "./lib/Group.js":
/*!**********************!*\
  !*** ./lib/Group.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Group {\n  #arrayOfComponents\n  #parent\n\n  constructor(arrayOfComponents, parent) {\n    this.#arrayOfComponents = arrayOfComponents;\n    this.#parent = parent\n    this.#createComponents();\n    this.#wrapper();\n  }\n\n  get components() {\n    return this.#arrayOfComponents\n  }\n\n  #createComponents() {\n    this.#arrayOfComponents = this.#arrayOfComponents.map(curr => {\n      if (curr.node)\n        return curr.createComponent();\n      else\n        return curr;\n    })\n  }\n\n  #wrapper() {\n    if(this.#parent)\n      this.#arrayOfComponents.forEach(comp => {\n        comp.elements[0].changeParent(this.#parent.node);\n      })\n  }\n\n  sortInDom(prop = 'id', order = 'ascending') {\n    // Sorts wrappers in groups based on \n    // f.e ID in the DOM elems and just use insertbefores to \n    // change only those that needs to change.\n    // You can also add so it regexes away for example \"task1\" so it just looks for the numbers. \n    /**\n     * Algoritmen:\n     * Nested Loop with one element, \n     * insertBefore on the first element that has the same or higher value than element\n     * \n     */\n  }\n\n  render() {\n    this.#arrayOfComponents.forEach(comp => {\n      comp.render();\n    })\n  }\n\n  unrender() {\n    this.#arrayOfComponents.forEach(comp => {\n      comp.unrender();\n    })\n  \n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Group);\n\n\n//# sourceURL=webpack://nova/./lib/Group.js?");

/***/ }),

/***/ "./lib/Router.js":
/*!***********************!*\
  !*** ./lib/Router.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Router {\n  #path\n  #componentArray\n  #hash\n  #rendered\n\n  constructor(path, componentArray, hash) {\n    this.#path = path;\n    this.#componentArray = componentArray;\n    this.#hash = hash;\n    this.#rendered = false;\n    this.#checkPath();\n  }\n\n  get path() {\n    return this.#path\n  }\n\n  set path(newPath) {\n    this.#path = newPath;\n  }\n\n  #checkPath() {\n    if (this.#hash) {\n      this.#addChangeListener();\n    } else if (this.path === window.location.pathname)\n        this.#render();\n    //Add regex for ID paths, /:id. \n  }\n\n  #render() {\n    this.#componentArray.forEach(comp => comp.render());\n    this.#rendered = true;\n  }\n\n  #unrender() {\n    this.#componentArray.forEach(comp => comp.unrender());\n    this.#rendered = false;\n  }\n\n  static getPath() {\n    return window.location.pathname;\n  }\n\n  static changePath(newPath) {\n    window.location.href = newPath;\n  }\n\n  static changeHash() {\n    window.dispatchEvent(new Event('locationChange'));\n  }\n\n  #addChangeListener() {\n    window.addEventListener('locationChange', () => {\n      const url = window.location.hash;\n      if (url === this.#path.replace('/', '') && !this.#rendered) {\n        this.#render();\n      } else if (this.#rendered) {\n        this.#unrender();\n      }\n    })\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Router);\n\n//# sourceURL=webpack://nova/./lib/Router.js?");

/***/ }),

/***/ "./lib/State.js":
/*!**********************!*\
  !*** ./lib/State.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass State {\n  #state;\n  #worker;\n  #listeners;\n  #actions;\n\n  constructor(worker, initialState) {\n    this.#worker = worker;\n    this.#state = initialState || {}\n    this.#listeners = [];\n    this.#actions = [];\n  }\n\n  get listeners() {\n    return this.#listeners;\n  }\n\n  get actions() {\n    return this.#actions;\n  }\n\n  getState() {\n    return this.#state;\n  }\n\n  //If you have a state ARRAY, you can get a portion of it by supplying id and keyname\n  getStateById(id, keyname = 'id') {\n    return this.#state.filter(fragment => fragment[keyname] === id);\n  }\n\n  static mergeWorkers(workers) {\n    return (state, action) => {\n      const stateObj = {};\n      for (const worker in workers) {\n        const newState = workers[worker](state[worker], action);\n        stateObj[worker] = newState\n      }\n\n      return stateObj\n    }\n  }\n\n  createAction(name, deps) {\n    const newAction = { name, deps };\n    //Should verify name if exists?\n    this.#actions.push(newAction);\n  }\n\n  getAction(name, deps) {\n    const index = this.#actions.findIndex(action => action.name === name)\n    if (deps)\n      this.#actions[index].deps = {...this.#actions[index].deps, ...deps };\n    return this.#actions[index].deps;\n  }\n\n  subscribe(listener) {\n    if (!this.#listeners.includes(listener)) \n      this.#listeners.push(listener);\n    \n    return () => {\n      const index = this.#listeners.indexOf(listener);\n      this.#listeners.splice(index, 1);\n    }\n  } \n\n  dispatch(action) {\n    this.#state = this.#worker(this.getState(), action);\n    this.#listeners.forEach(listener => {\n      if (typeof listener === 'object')\n        listener.updateState();\n      else\n        listener();\n    })\n  }\n\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (State);\n\n//# sourceURL=webpack://nova/./lib/State.js?");

/***/ }),

/***/ "./lib/nova.js":
/*!*********************!*\
  !*** ./lib/nova.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Element\": () => (/* reexport safe */ _Element__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"Generator\": () => (/* reexport safe */ _Generator__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   \"Component\": () => (/* reexport safe */ _Component__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"Group\": () => (/* reexport safe */ _Group__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   \"Router\": () => (/* reexport safe */ _Router__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   \"State\": () => (/* reexport safe */ _State__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   \"root\": () => (/* binding */ root)\n/* harmony export */ });\n/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Element */ \"./lib/Element.js\");\n/* harmony import */ var _Generator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Generator */ \"./lib/Generator.js\");\n/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Component */ \"./lib/Component.js\");\n/* harmony import */ var _Group__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Group */ \"./lib/Group.js\");\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Router */ \"./lib/Router.js\");\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./State */ \"./lib/State.js\");\n\n\n\n\n\n\n\nconst root = document.getElementById('root');\n\n\n\n//# sourceURL=webpack://nova/./lib/nova.js?");

/***/ }),

/***/ "./test/todolist/app.js":
/*!******************************!*\
  !*** ./test/todolist/app.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index */ \"./index.js\");\n\n// import header from './header'\n// import { search } from './search'\n// import { galleryWrapper } from './gallery';\n// import { paginationWrapper } from './pagination';\n// import footer from './footer'\n\nconst title = new _index__WEBPACK_IMPORTED_MODULE_0__.Element('h1', _index__WEBPACK_IMPORTED_MODULE_0__.root, { className: 'title', innerText: 'TO-DO'} );\nconst App = new _index__WEBPACK_IMPORTED_MODULE_0__.Group([\n  title,\n\n  ])\n\nnew _index__WEBPACK_IMPORTED_MODULE_0__.Router('/', [App])\n\n//# sourceURL=webpack://nova/./test/todolist/app.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./test/todolist/app.js");
/******/ 	
/******/ })()
;