/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Element\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.Element),\n/* harmony export */   \"Generator\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.Generator),\n/* harmony export */   \"Component\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.Component),\n/* harmony export */   \"Group\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.Group),\n/* harmony export */   \"Router\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.Router),\n/* harmony export */   \"State\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.State),\n/* harmony export */   \"root\": () => (/* reexport safe */ _lib_nova__WEBPACK_IMPORTED_MODULE_0__.root)\n/* harmony export */ });\n/* harmony import */ var _lib_nova__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/nova */ \"./lib/nova.js\");\n\n\n\n\n//# sourceURL=webpack://nova/./index.js?");

/***/ }),

/***/ "./lib/Component.js":
/*!**************************!*\
  !*** ./lib/Component.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n/**\n * @name Component\n * @class \n * @desc\n * The component is a wrapper for Elements. A component is basically a block of Elements.\n * The best way to create a Component is to use the Generator. \n * You can also supply it with an array of Elements. \n * @example\n * import { Generator } from 'nova';\n * const generator = new Generator();\n * const header = generator.createTree(`\n *   header className: 'header'\n *     h1 className: 'header__title' innerText: 'Hello World!'\n *     h2 className: 'header__subtitle' innerText: 'This is my site.'\n * end`)\n * \n * header.render(); //header is the component\n */\nclass Component {\n  #arrayOfElements;\n  #parent\n  #stateUpdaterArray\n\n  constructor(arrayOfElements, parent) {\n    this.#arrayOfElements = arrayOfElements;\n    this.#parent = parent || this.#arrayOfElements[0].parent;\n    this.#stateUpdaterArray = [];\n  }\n\n  /**\n   * @returns {ArrayOfElements}\n   */\n  get elements() {\n    return this.#arrayOfElements;\n  }\n\n  /**\n   * @desc\n   * Set props of a generated component using Generator. \n   * When generating the component, you need to put the value where you want to set the props as '{{whatever}}'.\n   * Then when supplying the propsObject to the setProps function, you set the value by { whatever: your-value }\n   * @param {Object} propsObject \n   * @example\n   * const task = generator.createTree(`\n   * article className: 'task' id: '{{id}}'\n   *   h2 className: 'task__title' innerText: '{{title}}'\n   *   p className: 'task__description' innerText: '{{description}}'\n   *   button className: 'task__remove-button' innerText: 'X'\n   *  end`)\n   *\n   *  task.setProps({\n   *  id: 1, \n   *  title: 'Buy Milk', \n   *  description: 'With chocolate taste',\n   *})\n   * \n   * @returns {void}\n   */\n  setProps(propsObject) {\n    for (const key in propsObject) {\n      const toFind = `{{${key}}}`;\n      this.#arrayOfElements.forEach(elem => {\n        for (const prop in elem.node) {\n          if (elem.node[prop] === toFind) {\n            elem.node[prop] = propsObject[key];\n            elem.props[prop] = propsObject[key];\n          }\n        }\n      })\n    }\n  }\n\n\n  /**\n   * @desc\n   * A clever way to set state directly to elements properties using Generator. \n   * It works similarily to setProps but with some modifications.\n   * To fully understand how this function works, it's recommended to read the docs about State and Generator first.\n   * When generating the component like setProps, you need to put the value where you want to set the state as '{{workerName.whateverProp}}' note the DOT '.'.\n   * \n   * When supplying the initial state to State, \n   * you should supply it as an object with the key name of the worker with the preferred value, f.e { whateverWorker: { whateverField: 'whateverValue' }} (See example below for clarification).\n   * The field is the name you supply when generating the elements (Check generator example below for clarification).\n   * \n   * The worker needs to return an object with all fields specified in the generator, else it will replace the state with undefined.\n   * Everytime the worker returns the object with the specified field, it will automatically update the value you supplied in the generator. \n   * \n   * This method is very useful when you want the state to be managed by the library instead of supplying custom functions to update the text.\n   * \n   * NOTE: The following example below is not using the intended project structure used for state, and should preferable be splitted into different files, \n   * but it's just a simple demonstration of how setState works.\n   * @example\n   * const whateverWorker = (state, action) => {\n   *  switch (action.type) {\n   *    case 'WHATEVER_ACTION':\n   *  return { whateverText: state[action.field] + action.appendText };\n   *  default:\n   *    return state;\n   *  }\n   * };\n   * \n   * const initState = { whateverWorker: { whateverText: 'yo' } };\n   * const workers = State.mergeWorkers({ whateverWorker });\n   * const state = new State(workers, initState);\n   * state.createAction('whateverAction', { type: 'WHATEVER_ACTION' });\n   * \n   * const generator = new Generator();\n   * const header = generator.createTree(`\n   *  header\n   *    div\n   *      h1 innerText: '{{whateverWorker.whateverText}}'\n   * end`);\n   * \n   * header.setState(state);\n   * state.subscribe(header);\n   * \n   * //Gets the div as in the order supplied to generator\n   * header.elements[1].addEventListener('click', () => {\n   *  state.dispatch(state.getAction('whateverAction', { appendText: 'HELLO', field: 'whateverText' }));\n   * })\n   * \n   * header.render();\n   * @param {Object} state \n   * @returns {void}\n   */\n  setState(state) {\n    const statesValues = state.getState();\n    for (const key in statesValues) {\n      const toFind = `{{${key.replace(/\\..+/gi, '')}}}`;\n      this.#arrayOfElements.forEach(elem => {\n        for (const prop in elem.node) {\n          if (String(elem.node[prop]).replace(/\\.[a-z]+/gi, '') === toFind) {\n            let properties = elem.node[prop].match(/(?<=\\.)[a-z]+/gi)[0] || null;\n            const updateState = () => {\n              if (properties) {\n                const stateObject = state.getState()[key];\n                elem.node[prop] = stateObject[properties];\n              }\n              else\n                elem.node[prop] = state.getState()[key];\n            }\n            updateState();\n            this.#stateUpdaterArray.push(updateState);\n          }\n        }\n      })\n    }\n  }\n\n  updateState() {\n    this.#stateUpdaterArray.forEach(func => {\n      func();\n    })\n  }\n\n  /**\n   * @desc\n   * A fluid function that returns the elements searched for in a component based on id, class or tag.\n   * It checks for # to find a id and in taht case returns the element directly. \n   * For tags and classes, it will always return an array of the found elements.\n   * @example\n   * const header = generator.createTree(`\n   *  div id: 'hello'\n   *    h1 innerText: 'Yo!'\n   *  div\n   *    h2 innerText: 'Welcome.' \n   * end`)\n   * \n   * const divWithIdHello = header.retrieve('#hello')\n   * const bothDivs = header.retrieve('div');\n   * \n   * @param {String} input \n   * @returns {Element}\n   */\n  retrieve(input) {\n    let retrievedElements = [];\n    if(input[0] === '#') {\n      retrievedElements = this.#arrayOfElements\n        .find(element => element.node.id === input.replace('#', ''));\n    } else if (input[0] === '.') {\n      this.#arrayOfElements.forEach(element => {\n        if (element.node.className === input.replace('.', '')) {\n          retrievedElements.push(element);\n        }\n      })\n    } else {\n      this.#arrayOfElements.forEach(element => {\n        if (element.type === input) {\n          retrievedElements.push(element);\n        }\n      })\n    }\n\n    return retrievedElements;\n  }\n\n  /**\n   * @desc\n   * Changes the components grandparent to another element supplied.\n   * \n   * @example\n   * const generator = new Generator();\n   *\n   *   const aNewParent = new Element('article', root, {}, true);\n   *\n   *   const header = generator.createTree(`\n   *     div id: 'grandparent'\n   *       h1 innerText: 'Welcome!'\n   *       div\n   *         h2 innerText: 'To my page...'\n   *         div \n   *         div\n   *   end`)\n   *\n   *   header.changeParent(aNewParent);\n   *   header.render();\n   * @param {Element} newParent \n   */\n  changeParent(newParent) {\n    this.#parent = newParent\n    this.#arrayOfElements[0].changeParent(newParent.node);\n  }\n\n  sortInDom(prop = 'id', order = 'ascending') {\n    // Sorts wrappers in groups based on \n    // f.e ID in the DOM elems and just use insertbefores to \n    // change only those that needs to change.\n    // You can also add so it regexes away for example \"task1\" so it just looks for the numbers. \n    /**\n     * Algoritmen:\n     * Nested Loop with one element, \n     * insertBefore on the first element that has the same or higher value than element\n     * \n     */\n  }\n\n  /**\n   * @desc\n   * Calls node.appendChild for every node inside the elements of the component.\n   */\n  render() {\n    this.#arrayOfElements.forEach(element => {\n      element.addNode();\n    })\n  }\n\n  /**\n   * @desc\n   * Calls node.removeChild for every node inside the elements of the component.\n   */\n  unrender() {\n    this.#arrayOfElements.forEach(element => {\n      if (!element.removed)\n        element.removeNode();\n    })\n  }\n\n\n  /**\n   * @desc\n   * Discards element inside component based on index, either from array supplied or the order from generator.createTree.\n   * Calling this before render has undefined behavior. \n   * Note that index 0 will remove the whole component. \n   * @param {Number} index \n   */\n  deleteByIndex(index) {\n    const targetElement = this.#arrayOfElements[index]\n    if (!targetElement.removed)\n      targetElement.removeNode();\n    this.#arrayOfElements.splice(index, 1);\n  }\n\n  /**\n   * @desc\n   * Deletes element based on ID, doesn't need any #.\n   * Else the same applies to this function as deleteByIndex.\n   * @param {String} id \n   */\n  deleteById(id) {\n    const index = this.#arrayOfElements.findIndex(elem => elem.id === id);\n    const targetElement = this.#arrayOfElements[index];\n    if (!targetElement.removed) \n      targetElement.removeNode();\n    this.#arrayOfElements.splice(index, 1);\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);\n\n\n//# sourceURL=webpack://nova/./lib/Component.js?");

/***/ }),

/***/ "./lib/Element.js":
/*!************************!*\
  !*** ./lib/Element.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _nova__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nova */ \"./lib/nova.js\");\n\n\n/**\n * @name Element\n * @class\n * @param {string} type\n * An htmlTag, for example 'div' or 'button'. \n * @param {Element|node} parent\n * The parent in the DOM you want the element to belong to.\n * @param {object} elementObject\n * An object containing the javascript props like: { innerText: 'helo' }\n * @param {boolean} init \n * A boolean to indicate if you want to render the element now (default: false). \n * @desc\n * The fundamental building block in Nova is the Element, which most other things in the library are built upon. \n * The element is just a shell of the normal javascript node but adds extra functionality \n * and shorter syntax to access and manipulate a node.\n * @example\n * import { Element, root } from 'nova';\n * const h1 = new Element('h1', root, { innerText: 'Hello World' }, true);\n * @returns void\n */\nclass Element {\n  #type;\n  #parent;\n  #node;\n  #elementObject;\n  #removed;\n  #init;\n\n  constructor(type, parent, elementObject, init) {\n    this.#type = type;\n    this.#parent = parent.node ? parent.node : parent;\n    this.#node = null;\n    this.#elementObject = elementObject;\n    this.#removed = true;\n    this.#init = init\n    this.#createNode();\n    this.#checkInit();\n  }\n  \n  /**\n   * @desc\n   * Return the node of the element\n   * @example\n   * const h1 = new Element('h1', root, { innerText: 'Hello World' }, true);\n   * console.log(h1.node) //returns node\n   * @return {node}\n   *  \n   */\n  get node() {\n    return this.#node;\n  }\n\n   /**\n   * @desc\n   * Return the type of the element\n   * @example\n   * const h1 = new Element('h1', root, { innerText: 'Hello World' }, true);\n   * console.log(h1.type) //returns 'h1'\n   * @return {type}\n   *  \n   */\n  get type() {\n    return this.#type;\n  }\n\n   /**\n   * @desc\n   * Return the parent of the element\n   * @example\n   * const h1 = new Element('h1', root, { innerText: 'Hello World' }, true);\n   * console.log(h1.parent) //returns node of root\n   * @return {parent}\n   */\n  get parent() {\n    return this.#parent;\n  }\n\n   /**\n   * @desc\n   * Return the value of the element\n   * @example\n   * const input = new Element('input', root, { type: 'text', value: 'some text' }, true);\n   * console.log(h1.value) //returns 'some text'\n   * @return {value}\n   */\n  get value() {\n    return this.#node.value;\n  }\n\n   /**\n   * @desc\n   * Return the id of the element\n   * @example\n   * const h1 = new Element('h1', root, { id: 'title', innerText: 'Welcome!' }, true);\n   * console.log(h1.id) //returns 'title'\n   * @return {id}\n   */\n  get id() {\n    return this.#node.id;\n  }\n\n  get className() {\n    return this.#node.className;\n  }\n\n  /**\n   * @desc\n   * Return the text of the element\n   * @example\n   * const h1 = new Element('h1', root, { id: 'title', innerText: 'Welcome!' }, true);\n   * console.log(h1.text) //returns 'Welcome!'\n   * @return {text}\n   */\n  get text() {\n    return this.#node.textContent;\n  }\n\n  /**\n   * @desc\n   * Return the innerHTML of the element\n   * @example\n   * const h1 = new Element('h1', root, { id: 'title', innerText: 'Welcome!' }, true);\n   * console.log(h1.html) //returns '<h1 id=\"title\">Welcome!</h1>'\n   * @return {html}\n   */\n  get html() {\n    return this.#node.innerHTML;\n  }\n\n   /**\n   * @desc\n   * Return the siblings of the element\n   * @example\n   * const h1 = new Element('h1', root, { id: 'title', innerText: 'Welcome,' }, true);\n   * const h2 = new Element('h2', root, { id: 'subtitle', innerText: 'To an awesome page!' }, true);\n   * console.log(h1.siblings) //returns a nodeArray of h1 and h2.\n   * @return {nodeArray}\n   */\n  get siblings() {\n    return this.parent.children;\n  }\n\n  get children() {\n    return this.node.children;\n  }\n\n  get removed() {\n    return this.#removed;\n  }\n\n  get props() {\n    return this.#elementObject;\n  }\n\n  #checkInit() {\n    if (this.#init) {\n      this.addNode();\n    } \n  }\n\n  #validateProps(elementObject) {\n    const options = this.#generateOptions();\n    for (const prop in elementObject) {\n      if (!options.includes(prop)) {\n        throw new Error(`Supplied property in updateNode call doesn't exist on type ${this.#type}`);\n      }\n    }\n  }\n\n  #createNode() {\n    const newNode = document.createElement(this.#type);\n    this.#node = newNode;\n    this.#validateProps(this.#elementObject);\n    for (const prop in this.#elementObject) {\n      this.#node[prop] = this.#elementObject[prop];\n    }    \n  }\n\n  #generateOptions() {\n    const optionsArray = [];\n    for (const opt in this.#node) {\n      optionsArray.push(opt);\n    }\n\n    return optionsArray;\n  }\n\n  /**\n   * @desc\n   * Dynamically updates the element by passing an object containing the props you want to update\n   * @param {object} elementObject\n   * An object containing the javascript props like: { innerText: 'helo' }\n   * @example\n   * const h1 = new Element('h1', root, { id: 'welcome', innerText: 'Hello World!' }, true);\n   * h1.updateNode({ id: 'goodbye', innerText: 'Goodbye World...' })\n   * @return {void}\n   */\n  updateNode(elementObject) {\n    this.#validateProps(elementObject);\n    this.#elementObject = { ...this.#elementObject, ...elementObject }\n    for (const prop in this.#elementObject) {\n      if (this.#node[prop] !== this.#elementObject[prop])\n        this.#node[prop] = this.#elementObject[prop];\n    }\n  }\n\n   /**\n   * @desc\n   * Toggles node on and off\n   * @example\n   * const h1 = new Element('h1', root, { id: 'welcome', innerText: 'Hello World!' }, true); //On with true\n   * h1.toggleNode() //Off\n   * h1.toggleNode() //On\n   * @return {void}\n   */\n  toggleNode() {\n    if (this.#removed === true) {\n      this.addNode();\n    } else {\n      this.removeNode();\n    }\n  } \n\n  /**\n   * @desc\n   * Appends node to parent. \n   * @example\n   * const h1 = new Element('h1', root, { id: 'welcome', innerText: 'Hello World!' }); //Off\n   * h1.addNode() //On\n   * @return {void}\n   */\n  addNode() {\n    this.parent.appendChild(this.node);\n    this.#removed = false;\n  }\n  \n   /**\n   * @desc\n   * Removes node from parent. \n   * @example\n   * const h1 = new Element('h1', root, { id: 'welcome', innerText: 'Hello World!'}, true); //On\n   * h1.removeNode() //Off\n   * @return {void}\n   */\n  removeNode() {\n    this.parent.removeChild(this.node);\n    this.#removed = true;\n  }\n\n  /**\n   * @desc\n   * Appends node to new parent. \n   * @param {Element|node} newParentNode\n   * @example\n   * const div = new Element('div', root, { className: 'container' }, true);\n   * const h1 = new Element('h1', root, { id: 'welcome', innerText: 'Hello World!'}, true); //Appends to root\n   * h1.changeParent(div); //Now h1 is appended to div instead.\n   * @return {void}\n   */\n  changeParent(newParentNode) {\n    if (newParentNode.node) {\n      newParentNode = newParentNode.node\n    }\n\n    if (this.#parent !== newParentNode) {\n      this.#parent = newParentNode;\n      this.#parent.appendChild(this.node);\n    }\n  }\n\n  /**\n   * @desc\n   * Calls addEventListener on node. \n   * @param {event} event //f.e 'click'\n   * Any javascript supported event. \n   * @param {function} callback\n   * Callback function to be invoked when event happens. \n   * @example\n   * Check https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n   * @return {void}\n   */\n  addEventListener(event, callback) {\n    this.node.addEventListener(event, callback); \n  }\n\n  /**\n   * @desc\n   * Dynamically adds css styles to Element.\n   * @param {string} property \n   * A string containing what you want to change, for example 'color'\n   * @param {string} css \n   * The css value to use, for example 'red'\n   * @return {void}\n   */\n  addStyle(property, css) {\n    this.#node.style[property] = css;\n  }\n\n  /**\n   * @desc\n   * Creates a component putting the element inside\n   */\n  createComponent() {\n    return new _nova__WEBPACK_IMPORTED_MODULE_0__.Component([this], this.parent);\n  }\n\n  /**\n   * @desc\n   * Moves node one step up the tree, changing place with it's previous sibling. \n   * @return {void}\n   */\n  beforeSibling() {\n    let childrenList = this.node.parentNode.children;\n    let indexPositionOfTarget = null;\n    for (let i = 0; i < childrenList.length; i++) {\n      if (childrenList[i] === this.node) {\n          indexPositionOfTarget = i;\n          break;\n      }\n    }\n\n    if (indexPositionOfTarget !== 0) {\n      const current = childrenList[indexPositionOfTarget];\n      const prev = childrenList[indexPositionOfTarget - 1]\n      this.#parent.insertBefore(current, prev)\n    } \n\n  }\n\n   /**\n   * @desc\n   * Moves node one step down the tree, changing place with it's next sibling. \n   * @return {void}\n   */\n  afterSibling() {\n    let childrenList = this.node.parentNode.children;\n    let indexPositionOfTarget = null;\n    for (let i = 0; i < childrenList.length; i++) {\n      if (childrenList[i] === this.node) {\n          indexPositionOfTarget = i;\n          break;\n      }\n    }\n\n    if (indexPositionOfTarget < childrenList.length - 1) {\n      const current = childrenList[indexPositionOfTarget];\n      const next = childrenList[indexPositionOfTarget + 1]\n      this.#parent.insertBefore(next, current)\n    } \n  }\n\n  /**\n   * @desc\n   * Appends node after a reference sibling\n   * @param {Element} reference \n   * @returns {void}\n   */\n  after(reference) {\n    const ref = reference.node.nextSibling;\n    if (ref)\n      this.parent.insertBefore(this.node, ref);\n    else \n      this.parent.appendChild(this.node);\n  }\n\n  /**\n   * @desc\n   * Appends node before a reference sibling\n   * @param {Element} reference \n   * @returns {void}\n   */\n  before(reference) {\n    if (reference)\n      this.parent.insertBefore(this.node, reference.node);\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Element);\n\n\n//# sourceURL=webpack://nova/./lib/Element.js?");

/***/ }),

/***/ "./lib/Generator.js":
/*!**************************!*\
  !*** ./lib/Generator.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _nova__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nova */ \"./lib/nova.js\");\n\n\n/**\n * @name Generator\n * @class\n * @desc\n * The generator is a powerful way to generate HTML without writing actual HTML!\n * It's meant to be very straightforward and to give your SPA a nice structure. No more angle brackets!\n * @example\n * import { Generator } from 'nova';\n * const generator = new Generator();\n * const header = generator.createTree(`\n *   header className: 'header'\n *     h1 className: 'header__title' innerText: 'Hello World!'\n *     h2 className: 'header__subtitle' innerText: 'This is my site.'\n * end`)\n * \n * header.render();\n */\nclass Generator {\n  constructor() {\n    this.tokens = [];\n    this.treeObjectArray = [];\n    this.indentationRule = 2\n    this.endToken = 'end'\n    this.rules = {\n      typeExpected: true,\n      valueExpected: false,\n      checkNextTypeIsValue: false\n    }\n  }\n\n  get elements() {\n    return this.elementsArray;\n  }\n\n  get tags() {\n    return [\"a\",\"abbr\",\"acronym\",\"address\",\"applet\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"basefont\",\"bb\",\"bdo\",\"big\",\"blockquote\",\"body\",\"br /\",\"button\",\"canvas\",\"caption\",\"center\",\"cite\",\"code\",\"col\",\"colgroup\",\"command\",\"datagrid\",\"datalist\",\"dd\",\"del\",\"details\",\"dfn\",\"dialog\",\"dir\",\"div\",\"dl\",\"dt\",\"em\",\"embed\",\"eventsource\",\"fieldset\",\"figcaption\",\"figure\",\"font\",\"footer\",\"form\",\"frame\",\"frameset\",\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\"head\",\"header\",\"hgroup\",\"hr /\",\"html\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"isindex\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"map\",\"mark\",\"menu\",\"meta\",\"meter\",\"nav\",\"noframes\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"pre\",\"progress\",\"q\",\"rp\",\"rt\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"small\",\"source\",\"span\",\"strike\",\"strong\",\"style\",\"sub\",\"sup\",\"table\",\"tbody\",\"td\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"tt\",\"u\",\"ul\",\"var\",\"video\",\"wbr\"]\n  }\n  \n  _generateElementsFromTree() {\n    const root = document.getElementById('root');\n    const elementsArray = [];\n    let priorityArray = [];\n    let lowestIndentation = 0;\n    let previousPriority = null;\n    \n    this.treeObjectArray.forEach((object, index) => {\n      if (index === 0) \n        lowestIndentation = object.priority\n      else\n        if (object.priority < lowestIndentation)\n          lowestIndentation = object.priority;\n    })\n\n    let iterations = 0;\n    let grandParent = false;\n    this.treeObjectArray.forEach((object) => {\n      let element;\n      if (object.priority === lowestIndentation) {\n        if (grandParent) {\n          throw new Error('Only one grandparent allowed!');\n        }\n\n        grandParent = true;\n        element = new _nova__WEBPACK_IMPORTED_MODULE_0__.Element(object.tag, root, object.propertyObject);\n        priorityArray = priorityArray.filter(elem => elem.priority <= object.priority - 2);\n      } else if (object.priority === (previousPriority + 2)) {\n        const parentObject = priorityArray.find(elem => elem.priority === object.priority - 2);\n        element = new _nova__WEBPACK_IMPORTED_MODULE_0__.Element(object.tag, parentObject.element, object.propertyObject);\n      } else if (object.priority <= (previousPriority - 2)) {\n        //Filter out everything that isn't grandparent\n        priorityArray = priorityArray.filter(elem => elem.priority <= object.priority - 2);\n        let parentObject = priorityArray.find(elem => elem.priority === object.priority - 2);\n        element = new _nova__WEBPACK_IMPORTED_MODULE_0__.Element(object.tag, parentObject.element, object.propertyObject);\n      } else if (object.priority === previousPriority) {\n        /* Removing previous priority so it doesn't interfere with paternity*/\n        priorityArray.splice(iterations - 1, 1);\n        iterations--;\n        const parentObject = priorityArray.find(elem => elem.priority === object.priority - 2);\n        element = new _nova__WEBPACK_IMPORTED_MODULE_0__.Element(object.tag, parentObject.element, object.propertyObject);\n      }\n\n      iterations++;\n      elementsArray.push(element);\n      priorityArray.push({ element, priority: object.priority });\n      previousPriority = object.priority;\n    })\n    \n    this.elementsArray = elementsArray;\n  }\n\n  _createTreeObjectFromTokens() {\n    this.tokens.forEach((line, index) => {\n      const indentation = line[0].indentation;\n      const treeObject = {};\n      const propertyObject = {};\n      let tokenValue = false;\n      for (let tokenIndex = 0; tokenIndex < line.length; tokenIndex++) {\n        if (line[tokenIndex].type === 'token_tag') {\n          treeObject.tag = line[tokenIndex].token;\n          treeObject.priority = indentation;\n          continue;\n        } \n\n        if (line[tokenIndex].type === 'token_property') {\n          propertyObject[line[tokenIndex].token] = line[tokenIndex + 1].token;\n          tokenIndex++;\n        }\n      }\n\n      treeObject.propertyObject = propertyObject;\n      this.treeObjectArray.push(treeObject);\n\n    })\n  }\n\n  _checkGrammar(currentToken, lineNumber, currentLineTokens) {\n    /** Grammars\n     * token_tag ex. div section form button\n     * token_property\n     * token_value \n     */\n    const tags = this.tags;\n    let returnType = '';\n\n    if (this.rules.typeExpected) {\n      if (tags.includes(currentToken)) {\n        returnType = 'token_tag';\n      } else if (currentToken === this.endToken) {\n        return 0;\n      } else {\n        console.table(currentToken);\n        throw new Error(`Invalid type, check if applied HTML tag on line ${lineNumber + 1} is valid. To see available tags, console.log(generator.tags)`)\n      }\n    }\n\n    if (this.rules.valueExpected) {\n      const lineType = currentLineTokens[0].token;\n        const testNode = document.createElement(lineType)\n        for (const elem in testNode) {\n          if (elem == currentToken)\n            returnType = 'token_property'\n        }\n\n        if (returnType !== 'token_property')\n          throw new Error(`Invalid property value ${currentToken} for ${lineType}`)\n        return 'token_property';\n    }\n\n    if (this.rules.checkNextTypeIsValue) {\n      if (currentToken[0] === '\\'' && currentToken[currentToken.length - 1] === '\\'') {\n        currentToken = currentToken.replace(/'/g, '');\n        returnType = 'token_value';\n      }\n    }\n\n    return returnType;\n  }\n\n  _generateTokens(inputArr) {\n    const arrayOfLines = inputArr.filter(elem => elem.length !== 0);\n    arrayOfLines.forEach((line, lineNumber) => {\n      const currentLineTokens = [];\n      this.rules.typeExpected = true;\n      let indentation = 0;\n      for (let i = 0; line[i] == ' '; i++) {\n        indentation++;\n      } \n\n      //Rule: Value Expected -- If ':' is found, next grammarcheck type needs to be 'value' else throw error\n      let currentToken = '';\n      let lastChar = ''\n      for (let lineIndex = indentation; lineIndex <= line.length; lineIndex++) {\n        if ((line[lineIndex] !== ' ' && lineIndex !== line.length) && line[lineIndex]) {\n          if (this.rules.valueExpected && line[lineIndex] !== '\\'') \n            throw new Error('Missing \\' after :');         \n\n          if (line[lineIndex] === ':') {\n            this.rules.valueExpected = true;\n            continue;\n          }\n\n          currentToken += line[lineIndex];\n          lastChar = line[lineIndex];\n        } else if (this.rules.checkNextTypeIsValue && lastChar !== '\\'') {\n          currentToken += line[lineIndex];\n          lastChar = line[lineIndex];\n        } else {\n          //Validate token\n          const type = this._checkGrammar(currentToken, lineNumber, currentLineTokens)\n\n          if (this.rules.typeExpected && type !== 'token_tag' && currentToken !== this.endToken) \n            throw new Error(\"type expected as first token! ex. div\");\n          this.rules.typeExpected = false;\n\n          if (this.rules.checkNextTypeIsValue && type !== 'token_value') \n            throw new Error(\"'value' expected after after token_property\")\n          this.rules.checkNextTypeIsValue = false;\n\n          if (this.rules.valueExpected) {\n            this.rules.checkNextTypeIsValue = true;\n            this.rules.valueExpected = false;\n          }\n\n          if (type === 'token_value') \n            currentToken = currentToken.replace(/'/g, '');\n          currentLineTokens.push({ token: currentToken, type });\n          currentToken = '';\n        }\n      }\n\n      currentLineTokens.unshift({ indentation })\n      this.tokens.push(currentLineTokens);\n    })\n  }\n\n  /**\n   * 'createTree' is the method you can use to generate HTML stored in a Component as Elements. \n   * The string has to be in a certain format where indentations are very important.\n   * Indentations are what dictates if an element is a parent/child. Always use even indentations, 2 spaces per child. \n   * The structure is always the same: `[indentation][htmlTag][property]: '[value]'`.\n   * Note that you need to to use only one grandparent for all the element generated, else it will throw an error!.\n   * like: \n   * @example\n   * `  h1 innerText: 'helo'`\n   * Valid properties are for specific a htmlTag. For example, you can use 'type' on 'input' but not on 'h1'\n   * @example\n   * ` form\n   *     input type: 'text'\n   * end`\n   * \n   * Indentation dictates children/parent\n   * @example\n   * `\n   *   div className: 'grandparent'\n   *     main className: 'parent'\n   *       p className: 'child' innerText: 'I am a child of main'    \n   * end`  \n   * \n   * Always end the string on a new line with the word 'end'\n   *  \n   * Full example\n   * @example\n   * import { Generator } from 'nova';\n   * const generator = new Generator();\n   * const header = generator.createTree(`\n   *   header className: 'header'\n   *     h1 className: 'header__title' innerText: 'Hello World!'\n   *     h2 className: 'header__subtitle' innerText: 'This is my site.'\n   *     nav id: 'menu'\n   *       ul className: 'menu__items'\n   *         li innerText: 'First item'\n   *         li innerText: 'Second item'\n   *   end`)\n   * @param {string} input \n   * @returns {Component}\n   */\n  createTree(input, indentationRule = 2) {\n    this.indentationRule = indentationRule;\n    const splitByNewLines = input.split('\\n');\n    this._generateTokens(splitByNewLines);\n    this._createTreeObjectFromTokens();\n    this._generateElementsFromTree();\n    this.elementsArray.pop();\n    const elementsArray = [...this.elementsArray]\n    this._defaultGenerator()\n    return new _nova__WEBPACK_IMPORTED_MODULE_0__.Component(elementsArray)\n  } \n\n  _defaultGenerator() {\n    this.tokens = [];\n    this.treeObjectArray = [];\n    this.indentationRule = 2\n    this.endToken = 'end'\n    this.rules = {\n      typeExpected: true,\n      valueExpected: false,\n      checkNextTypeIsValue: false\n    }\n    this.elementsArray = [];\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Generator);\n\n//# sourceURL=webpack://nova/./lib/Generator.js?");

/***/ }),

/***/ "./lib/Group.js":
/*!**********************!*\
  !*** ./lib/Group.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @name Group\n * @class\n * @desc\n * A group is a wrapper for components where it's possible to do bulk operations.\n * This is very usefuly when you want a group of components to have the same parent.\n * In a situation where you want to append new components, for example in a todo-list, \n * it's highly recommended to wrap them all in a group so they share the same grandparent. \n * @example\n * const taskOne = generator.createTree(`\n *  ...\n * `)\n * \n * const taskTwo = ...\n * \n * \n * const taskWrapper = new Element('section', root, { className: 'task-wrapper' });\n * const tasks = new Group([taskOne, taskTwo], taskWrapper);\n * tasks.render();\n * \n * @param {Components[]} arrayOfComponents - An array of components, every element will be automatically converted to a component. \n * @param {Element} parent - Element used to wrap the components, changing the grandparent node. \n */\n\nclass Group {\n  #arrayOfComponents\n  #parent\n\n  constructor(arrayOfComponents, parent) {\n    this.#arrayOfComponents = arrayOfComponents || [];\n    this.#parent = parent\n    this.#createComponents();\n    this.#wrapper();\n  }\n\n  /** \n   * @desc\n   * Returns an array of components\n   * @returns {Component[]}\n   */\n  get components() {\n    return this.#arrayOfComponents\n  }\n\n  #createComponents() {\n    this.#arrayOfComponents = this.#arrayOfComponents.map(curr => {\n      if (curr.node)\n        return curr.createComponent();\n      else\n        return curr;\n    })\n  }\n\n  #wrapper() {\n    if (this.#parent) {\n      this.#arrayOfComponents.forEach(comp => {\n        comp.elements[0].changeParent(this.#parent.node);\n      })\n    }\n  }\n\n  sortInDom(prop = 'id', order = 'ascending') {\n    // Sorts wrappers in groups based on \n    // f.e ID in the DOM elems and just use insertbefores to \n    // change only those that needs to change.\n    // You can also add so it regexes away for example \"task1\" so it just looks for the numbers. \n    /**\n     * Algoritmen:\n     * Nested Loop with one element, \n     * insertBefore on the first element that has the same or higher value than element\n     * \n     */\n  }\n\n  /**\n   * @desc\n   * Calls render on all Components inside Group. Same as Component.render().\n   */\n  render() {\n    this.#arrayOfComponents.forEach(comp => {\n      comp.render();\n    })\n  }\n\n  /**\n   * @desc\n   * Adds a new component to the group dynamically. \n   * This also has the effect of assigning the wrapper grandparent to the added component.\n   * Very useful when you are adding new components dynamically to the DOM, like more todos in a list.\n   * @param {Component} component \n   */\n  add(component) {\n    this.#arrayOfComponents = [...this.#arrayOfComponents, component];\n    component.elements[0].changeParent(this.#parent.node);\n    this.render();\n  }\n\n  /**\n   * @desc\n   * Replaces the components in the group with a new array of components. \n   * @param {Component[]} arrayOfComponents \n   */\n  update(arrayOfComponents) {\n    this.arrayOfComponents = arrayOfComponents;\n    this.#wrapper();\n    this.render();\n  }\n\n  /**\n   * @desc\n   * Calls unrender on all components. Same as Component.unrender().\n   */\n  unrender() {\n    this.#arrayOfComponents.forEach(comp => {\n      comp.unrender();\n    })\n  }\n\n  /**\n   * @desc\n   * Retrieve a component in a group. At the moment only supports ids.\n   * @param {String} id \n   * @returns \n   */\n  retrieve(id) {\n    const comp = this.#arrayOfComponents.find(comp => comp.retrieve(`#${id}`))\n    return comp.elements;\n  }\n\n  /**\n   * @desc\n   * Deletes a component in a group by id. \n   * @param {String} id \n   */\n  deleteById(id) {\n    let index;\n    this.#arrayOfComponents.forEach((comp, i) => {\n      if (comp.elements[0].id === id) {\n        index = i;\n        while (comp.elements.length > 0)\n          comp.deleteByIndex(0);\n      }\n    })\n    \n    this.#arrayOfComponents.splice(index, 1);\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Group);\n\n\n//# sourceURL=webpack://nova/./lib/Group.js?");

/***/ }),

/***/ "./lib/Router.js":
/*!***********************!*\
  !*** ./lib/Router.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @name Router\n * @class\n * @desc\n * To get the full SPA feel the router is here for rendering different groups or components based on the url. \n * \n * @example\n *  import { Router, Group, Element, Generator, root } from '../../';\n * \n *  const wrapper = new Element('div', root, { id: 'wrapper' }, true);\n *\n *  const generator = new Generator;\n *  const component = generator.createTree(`\n *    div\n *      h1 innerText: 'Router example.'\n *      button innerText: 'Click it'\n *  end`)\n *\n *  component.retrieve('button')[0].addEventListener('click', () => {\n *    Router.changePath('/about');\n *  })\n *\n *  const about = new Element('h1', root, { innerText: 'Hello there!'}).createComponent();\n *  const group = new Group([component], wrapper);\n *\n *  new Router('/', [group])\n *  new Router('/about', [about]);\n * \n * @param {String} path - The path bound to this route. All components applied will be rendered only when the URI is the same.\n * @param {Components[]} componentArray - Array of components. If you want to supply an element you can do Element.createComponent();\n */\nclass Router {\n  #path\n  #componentArray\n  #rendered\n\n  constructor(path, componentArray) {\n    this.#path = path;\n    this.#componentArray = componentArray;\n    this.#rendered = false;\n    this.#checkPath();\n  }\n\n  get path() {\n    return this.#path\n  }\n\n  set path(newPath) {\n    this.#path = newPath;\n  }\n\n  #checkPath() {\n    this.#addChangeListener();\n    if (this.path === window.location.pathname) {\n      this.#render();\n    }\n  }\n\n  #render() {\n    this.#componentArray.forEach(comp => comp.render());\n    this.#rendered = true;\n  }\n\n  #unrender() {\n    this.#componentArray.forEach(comp => comp.unrender());\n    this.#rendered = false;\n  }\n\n  /**\n   * @desc\n   * Returns current url path\n   * @returns current path\n   */\n  static getPath() {\n    return window.location.pathname;\n  }\n\n  /**\n   * @desc\n   * A static mathod that uses history.pushState to set new url location.\n   * @example\n   * Router.newPath('/contact');\n   * @param {String} newPath\n   */\n  static changePath(newPath) {\n    window.history.pushState({}, '', newPath);\n    window.dispatchEvent(new Event('locationChange'));\n  }\n\n  #addChangeListener() {\n    ['locationChange', 'popstate'].forEach(state => {\n      window.addEventListener(state, () => {\n        const url = window.location.pathname;\n        if (url === this.#path && !this.#rendered) {\n          this.#render();\n        } else if (this.#rendered) {\n          this.#unrender();\n        }\n      })\n    })\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Router);\n\n//# sourceURL=webpack://nova/./lib/Router.js?");

/***/ }),

/***/ "./lib/State.js":
/*!**********************!*\
  !*** ./lib/State.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @name State\n * @class\n * @desc\n * State management system for Nova. Heavily inspired by Redux with a similar system but in a way, more compact.\n * @example\n * const whateverWorker = (state, action) => {\n *  switch (action.type) {\n *    case 'WHATEVER_ACTION':\n *      return { whateverText: state[action.field] + action.appendText };\n *      default:\n *    return state;\n *  }\n * };\n * \n * const initState = { whateverWorker: { whateverText: 'yo' } };\n * const workers = State.mergeWorkers({ whateverWorker });\n * const state = new State(workers, initState);\n * state.createAction('whateverAction', { type: 'WHATEVER_ACTION' });\n * \n * const generator = new Generator();\n * const header = generator.createTree(`\n *  header\n *    div\n *      h1 innerText: '{{whateverWorker.whateverText}}'\n * end`);\n * \n * header.setState(state);\n * state.subscribe(header);\n * \n * //Gets the div as in the order supplied to generator\n * header.elements[1].addEventListener('click', () => {\n *  state.dispatch(state.getAction('whateverAction', { appendText: 'HELLO', field: 'whateverText' }));\n * })\n */\nclass State {\n  #state;\n  #worker;\n  #listeners;\n  #actions;\n\n  constructor(worker, initialState) {\n    this.#worker = worker;\n    this.#state = initialState || {}\n    this.#listeners = [];\n    this.#actions = [];\n  }\n\n  get listeners() {\n    return this.#listeners;\n  }\n\n  get actions() {\n    return this.#actions;\n  }\n\n  /**\n   * @desc\n   * Returns the state object.\n   * @example\n   * const initState = { whateverWorker: { title: 'Yo!', desc: 'Hello there...' } };\n   * const state = new State(workers, init);\n   * \n   * const whateverWorkerState = state.getState().whateverWorker;\n   *\n   * @returns {Object} state object\n   */\n  getState() {\n    return this.#state;\n  }\n\n  /**\n   * @desc\n   * MergeWorkers is a static method that should always be used before supplying workers to state initialization.\n   * \n   * @example\n   * const exampleWorkerOne = (state, action) => {\n   *   switch(action.type) {\n   *     case 'ACTION': \n   *      return state.someText + 'hello again!';\n   *     default:\n   *       return state;\n   *   }\n   * }\n   * \n   * const exampleWorkerTwo = (state, action) => {\n   *  ...\n   * }\n   * \n   * const initState = { exampleWorkerOne: { someText: 'hello, '}, exampleWorkerTwo: ... } \n   * const workers = State.mergeWorkers({ exampleWorkerOne, exampleWorkerTwo });\n   * const state = new State(workers, initState);\n   * \n   * @param {Object} workers takes and object that have the function as a key-value pair with same name\n   * @returns {Object} state object\n   */\n  static mergeWorkers(workers) {\n    return (state, action) => {\n      const stateObj = {};\n      for (const worker in workers) {\n        const newState = workers[worker](state[worker], action);\n        stateObj[worker] = newState\n      }\n\n      return stateObj\n    }\n  }\n\n  /**\n   * @desc\n   * Creates the action for the worker, which you can access from the action argument in the callback. \n   * The name supplied as the first argument needs to be unique for every action.\n   * @example\n   * state.createAction('actionName', { type: 'ACTION' })\n   * @param {String} name - unique name for action.\n   * @param {Object} deps - object containing prop \"type\".\n   */\n  createAction(name, deps) {\n    const newAction = { name, deps };\n    this.#actions.forEach(action => {\n      if (action.name === newAction.name) {\n        throw new Error(`Action name \"${action.name}\" already exists... Please choose a different one!`);\n      }\n    })\n\n    this.#actions.push(newAction);\n  }\n\n  /**\n   * @desc\n   * This function is used to set new dependencies to a specific action.\n   * Prefarably called together with dispatch as the argument.\n   * The dependency can contain an optional property for use when setting up state together with \"setState\". \n   * See Component for more info regarding the optional property.\n   * @example\n   * state.dispatch(state.getAction('actionName', { someText: 'helo', optionalProperty: 'title' })); \n   * @param {String} name - the name of the action.\n   * @param {Object} deps - the dependencies that will be accessible through the action argument in the worker.\n   * @returns {Objectt} - returns the dependencies. \n   */\n  getAction(name, deps) {\n    const index = this.#actions.findIndex(action => action.name === name)\n    if (deps)\n      this.#actions[index].deps = {...this.#actions[index].deps, ...deps };\n    return this.#actions[index].deps;\n  }\n\n  /**\n   * @desc\n   * The subscribe function takes 3 different listeners as an argument. \n   * If you use \"setState\" together with a component, you will supply the component as the argument.\n   * Generelly when not using \"setState\", you want to supply an object with the action type and function.\n   * This will make sure that the function only gets called when the specific action is set, see example.\n   * If you supply a function directly, that one will get called every time you use dispatch, \n   * which is generelly unnecessary.\n   * @example\n   * state.subscribe(header); //Component\n   * state.subscribe({ type: 'TASK_ADD', func: addTask }); //Only called when \"TASK_ADD\" is dispatched.\n   * state.subscribe(addTask); //Called every dispatch.\n   * @param {Component | Object | Function} listener \n   * @returns {Function} . unsubscribe function, call it to remove listener.\n   */\n  subscribe(listener) {\n    if (!this.#listeners.includes(listener)) \n      this.#listeners.push(listener);\n    \n    return () => {\n      const index = this.#listeners.indexOf(listener);\n      this.#listeners.splice(index, 1);\n    }\n  } \n  /**\n   * @desc\n   * Dispatch is what you call to update state.\n   * It's preferable to call it together with \"getAction\".\n   * It first calls the worker to get the state and modifications.\n   * Then it will call the listener you supplied with subscribe.\n   * How it will call the listener depends on what type of listener you called subscribe with.\n   * @example\n   * state.dispatch(state.getAction('actionName', { someText: 'helo', optionalProperty: 'title' })); \n   * @param {Object} action - the dependencies supplied, see \"getAction\".\n   */\n  dispatch(action) {\n    this.#state = this.#worker(this.getState(), action);\n    this.#listeners.forEach(listener => {\n      if (typeof listener === 'object') {\n        if (listener.type === action.type) {\n          listener.func();\n        } else if (listener.updateState)\n          listener.updateState();\n      } else listener();\n    })\n  }\n\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (State);\n\n//# sourceURL=webpack://nova/./lib/State.js?");

/***/ }),

/***/ "./lib/nova.js":
/*!*********************!*\
  !*** ./lib/nova.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Element\": () => (/* reexport safe */ _Element__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"Generator\": () => (/* reexport safe */ _Generator__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   \"Component\": () => (/* reexport safe */ _Component__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"Group\": () => (/* reexport safe */ _Group__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   \"Router\": () => (/* reexport safe */ _Router__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   \"State\": () => (/* reexport safe */ _State__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   \"root\": () => (/* binding */ root)\n/* harmony export */ });\n/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Element */ \"./lib/Element.js\");\n/* harmony import */ var _Generator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Generator */ \"./lib/Generator.js\");\n/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Component */ \"./lib/Component.js\");\n/* harmony import */ var _Group__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Group */ \"./lib/Group.js\");\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Router */ \"./lib/Router.js\");\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./State */ \"./lib/State.js\");\n\n\n\n\n\n\n\nconst root = document.getElementById('root');\n\n\n\n//# sourceURL=webpack://nova/./lib/nova.js?");

/***/ }),

/***/ "./test/Router/index.js":
/*!******************************!*\
  !*** ./test/Router/index.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ */ \"./index.js\");\n\n\nconst wrapper = new ___WEBPACK_IMPORTED_MODULE_0__.Element('div', ___WEBPACK_IMPORTED_MODULE_0__.root, { id: 'wrapper' }, true);\n\nconst generator = new ___WEBPACK_IMPORTED_MODULE_0__.Generator;\nconst component = generator.createTree(`\n  div\n    h1 innerText: 'Router example.'\n    button innerText: 'Click it'\nend`)\n\ncomponent.retrieve('button')[0].addEventListener('click', () => {\n  ___WEBPACK_IMPORTED_MODULE_0__.Router.changePath('/about');\n})\n\nconst about = new ___WEBPACK_IMPORTED_MODULE_0__.Element('h1', ___WEBPACK_IMPORTED_MODULE_0__.root, { innerText: 'Hello there!'}).createComponent();\nconst group = new ___WEBPACK_IMPORTED_MODULE_0__.Group([component], wrapper);\n\nnew ___WEBPACK_IMPORTED_MODULE_0__.Router('/', [group])\nnew ___WEBPACK_IMPORTED_MODULE_0__.Router('/about', [about]);\n\n//# sourceURL=webpack://nova/./test/Router/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./test/Router/index.js");
/******/ 	
/******/ })()
;